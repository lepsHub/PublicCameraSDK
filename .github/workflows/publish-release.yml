name: Publish Release

on:
  workflow_call:
    inputs:
      cut:
        type: string
        required: true
      frameworks:
        type: string
        required: true
      dry_run:
        type: boolean
        default: false
        required: false

jobs:
  publish:
    runs-on: macos-15

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - uses: actions/download-artifact@v4
        name: Fetch XCFramework artifacts
        with:
          name: xcframeworks
          path: build

      - name: Tooling
        run: |
          brew update >/dev/null
          brew install jq >/dev/null || true
          git config user.name  "truvideo[bot]"
          git config user.email "truvideo[bot]@users.noreply.github.com"

      - name: Publish Release
        shell: bash
        env:
          GH_TOKEN: ${{ github.token }}
          TAGPFX_CAM: 'CameraSDK'
          TAGPFX_CORE: 'CoreSDK'
          CHANNEL_PLIST_KEY: 'TRVReleaseChannel'
        run: |
          set -euo pipefail
          set -x
          trap 'echo "âŒ Error at line $LINENO: $BASH_COMMAND"' ERR

          cut="${{ inputs.cut }}"
          dry="${{ inputs.dry_run }}"

          echo ">>> Cut types: $cut"
          echo ">>> Frameworks to process: ${{ inputs.frameworks }}"
          echo ">>> Dry run: $dry"

          #
          # Helpers (copiados 1:1 del workflow original)
          #
          find_plists () { git ls-files "$1" | grep -E '/Info\.plist$' || true; }
          read_short_ver () { /usr/libexec/PlistBuddy -c "Print :CFBundleShortVersionString" "$1" 2>/dev/null || true; }
          write_short_ver () { /usr/libexec/PlistBuddy -c "Set :CFBundleShortVersionString $2" "$1" || /usr/libexec/PlistBuddy -c "Add :CFBundleShortVersionString string $2" "$1"; }
          write_build_num () { /usr/libexec/PlistBuddy -c "Set :CFBundleVersion $2" "$1" || /usr/libexec/PlistBuddy -c "Add :CFBundleVersion string $2" "$1"; }
          write_channel_key () {
            local plist="$1" val="$2" key="${CHANNEL_PLIST_KEY}"
            /usr/libexec/PlistBuddy -c "Set :$key $val" "$plist" \
              || /usr/libexec/PlistBuddy -c "Add :$key string $val" "$plist"
          }

          bump_from_commits () {
            local last_prod="$1" range="$2" bump="patch"
            if git log --format=%B $range | grep -Eq 'BREAKING CHANGE|!:'; then bump="major"
            elif git log --format=%s $range | grep -Eq '^feat(\(|:)|^feat!'; then bump="minor"
            elif git log --format=%s $range | grep -Eq '^fix(\(|:)|^fix!|^perf(\(|:)|^perf!'; then bump="patch"
            else bump="patch"; fi
            if [ -z "$last_prod" ]; then echo "0.1.0"; return; fi
            base="${last_prod##*-}"
            IFS='.' read -r major minor patch <<< "$base"
            case "$bump" in
              major) major=$((major+1)); minor=0; patch=0 ;;
              minor) minor=$((minor+1)); patch=0 ;;
              patch) patch=$((patch+1)) ;;
            esac
            echo "${major}.${minor}.${patch}"
          }

          next_global_build_number() {
            local prefix="$1" base="$2" max=0
            while read -r t; do
              [ -z "$t" ] && continue
              n="${t##*.}"
              [[ "$n" =~ ^[0-9]+$ ]] && {
                [ "$n" -gt "$max" ] && max="$n"
              }
            done < <(
              git tag -l "${prefix}-${base}-BETA.*"
              git tag -l "${prefix}-${base}-RC.*"
            )
            echo $((max + 1))
          }

          gen_version_swift () {
            local destdir="$1" full="$2" channel="$3" build="$4"
            mkdir -p "$destdir"
            cat > "$destdir/Version.swift" <<SWIFT
          // Generated by CI â€“ do not edit.
          public let SDKVersionNumber: String = "$full"
          public let SDKEnvironment:   String = "$channel"
          public let SDKBuildNumber:   String = "$build"
          SWIFT
          }

          gen_changelog_md () {
            local range="$1" path="$2"
            local feats="" fixes="" perfs="" refacs="" docs="" tests="" build="" ci="" chores="" breaks=""
            while IFS= read -r s; do
              [ -z "$s" ] && continue
              [[ "$s" =~ BREAKING\ CHANGE|!\: ]] && breaks="${breaks}"$'\n- '"$s"
              if   [[ "$s" =~ ^feat(\(|:|\!) ]];      then feats="${feats}"$'\n- '"$s"
              elif [[ "$s" =~ ^fix(\(|:|\!) ]];       then fixes="${fixes}"$'\n- '"$s"
              elif [[ "$s" =~ ^perf(\(|:|\!) ]];      then perfs="${perfs}"$'\n- '"$s"
              elif [[ "$s" =~ ^refactor(\(|:|\!) ]];  then refacs="${refacs}"$'\n- '"$s"
              elif [[ "$s" =~ ^docs(\(|:|\!) ]];      then docs="${docs}"$'\n- '"$s"
              elif [[ "$s" =~ ^test(\(|:|\!) ]];      then tests="${tests}"$'\n- '"$s"
              elif [[ "$s" =~ ^build(\(|:|\!) ]];     then build="${build}"$'\n- '"$s"
              elif [[ "$s" =~ ^ci(\(|:|\!) ]];        then ci="${ci}"$'\n- '"$s"
              elif [[ "$s" =~ ^chore(\(|:|\!) ]];     then chores="${chores}"$'\n- '"$s"
              fi
            done < <(git log --pretty=format:'%s' $range -- "$path" || true)

            {
              echo "## Changes"
              [ -n "$breaks" ] && { echo; echo "### âš ï¸ Breaking Changes"; echo "$breaks"; }
              [ -n "$feats"  ] && { echo; echo "### âœ¨ Features";        echo "$feats"; }
              [ -n "$fixes"  ] && { echo; echo "### ðŸ› Fixes";           echo "$fixes"; }
              [ -n "$perfs"  ] && { echo; echo "### ðŸš€ Performance";     echo "$perfs"; }
              [ -n "$refacs" ] && { echo; echo "### ðŸ§¹ Refactors";       echo "$refacs"; }
              [ -n "$docs"   ] && { echo; echo "### ðŸ“ Docs";            echo "$docs"; }
              [ -n "$tests"  ] && { echo; echo "### âœ… Tests";           echo "$tests"; }
              [ -n "$build"  ] && { echo; echo "### ðŸ§± Build";           echo "$build"; }
              [ -n "$ci"     ] && { echo; echo "### âš™ï¸ CI";              echo "$ci"; }
              [ -n "$chores" ] && { echo; echo "### ðŸ§° Chore";           echo "$chores"; }
            } | sed '/^$/N;/^\n$/D' || true
          }

          #
          # The main entry point: cut_for
          #
          cut_for () {
            local key="$1" cut_type="$2" prefix path vdir channel full base_ver build_num prerelease title

            case "$key" in
              "cam")
                prefix="${TAGPFX_CAM}"
                path="Libraries/Plugins/Camera/"
                vdir="Sources/CameraSDK/Generated"
                SCHEME="CameraSDK"
                ;;
              "core")
                prefix="${TAGPFX_CORE}"
                path="Libraries/External/Extended/App/"
                vdir="Sources/CoreSDK/Generated"
                SCHEME="CoreSDK"
                ;;
            esac

            last_prod=$(
              git tag -l "${prefix}-*" --sort=-v:refname \
              | grep -E "^${prefix}-[0-9]+\.[0-9]+\.[0-9]+$" \
              | head -n1
            )

            since_ref=""; [ -n "$last_prod" ] && since_ref="$(git rev-list -n1 "$last_prod")"
            range="${since_ref:+${since_ref}..}HEAD"

            base_ver="$(bump_from_commits "$last_prod" "${range:-HEAD}")"

            if [ "$cut_type" = "beta" ]; then
              channel="BETA"
              build_num="$(next_global_build_number "$prefix" "$base_ver")"
              full="${base_ver}-BETA.${build_num}"
              prerelease="true"
              title="Internal BETA release for $prefix $base_ver."
            elif [ "$cut_type" = "rc" ]; then
              channel="RC"
              build_num="$(next_global_build_number "$prefix" "$base_ver")"
              full="${base_ver}-RC.${build_num}"
              prerelease="true"
              title="Release Candidate for $prefix $base_ver."
            else
              channel="PROD"
              full="${base_ver}"
              bn="$(next_global_build_number "$prefix" "$base_ver")"
              [ "$bn" -gt 0 ] && build_num="$bn" || build_num="1"
              prerelease="false"
              title="Production release for $prefix $base_ver."
            fi

            #
            # Update plists
            #
            while read -r plist; do
              [ -z "$plist" ] && continue
              cur_short="$(read_short_ver "$plist")"
              if [ "$cur_short" != "$base_ver" ]; then write_short_ver "$plist" "$base_ver"; fi
              write_build_num "$plist" "$build_num"
              write_channel_key "$plist" "$channel"
            done < <(find_plists "$path")

            #
            # Create Version.swift
            #
            gen_version_swift "$vdir" "$full" "$channel" "$build_num"

            #
            # Prepare changelog body
            #
            chg="$(gen_changelog_md "$range" "$path")"

            body_header=$(printf '%s\n' \
              "%TITLE%" \
              "" \
              "- **CFBundleShortVersionString**: %BASE%" \
              "- **CFBundleVersion**: %BUILD%" \
              "- **SdkVersionNumber**: %FULL%" \
              "- **Channel**: %CHANNEL%" \
              "" \
              "%CHANGELOG%")
            body="${body_header//%TITLE%/$title}"
            body="${body//%BASE%/$base_ver}"
            body="${body//%BUILD%/$build_num}"
            body="${body//%FULL%/$full}"
            body="${body//%CHANNEL%/$channel}"
            body="${body//%CHANGELOG%/$chg}"

            tag="${prefix}-${full}"

            if [ "$dry" = "true" ]; then
              echo "[DRY RUN] Would tag: $tag"
              echo "[DRY RUN] Would create release:"
              echo "$body"
              return 0
            fi

            #
            # Commit the version bump
            #
            git add "$path" || true
            if [ -f "$vdir/Version.swift" ] && ! git check-ignore -q "$vdir/Version.swift"; then
              git add "$vdir/Version.swift"
            fi
            if ! git diff --cached --quiet; then
              git commit -m "chore(release): bump ${prefix} to ${full} (${channel})"
            fi

            #
            # External repo mapping
            #
            if [ "$key" = "cam" ]; then
              external_repo="lepsHub/PublicCameraSDK"
            else
              external_repo="lepsHub/PublicCoreSDK"
            fi

            external_prefixless_tag="$full"

            #
            # Push external lightweight tag
            #
            git tag "$external_prefixless_tag" || true
            git push "https://${{ secrets.GH_EXTERNAL_PAT }}@github.com/${external_repo}.git" "refs/tags/${external_prefixless_tag}"

            #
            # Upload XCFramework (already built)
            #
            ZIP_NAME="${external_prefixless_tag}-${key}.xcframework.zip"
            cp "build/${SCHEME}.xcframework.zip" "/tmp/${ZIP_NAME}"

            #
            # Create release in external repo
            #
            gh api \
              -X POST \
              "repos/${external_repo}/releases" \
              -f tag_name="$external_prefixless_tag" \
              -f name="$external_prefixless_tag" \
              -f body="$body" \
              -F prerelease=$prerelease >/dev/null

            gh release upload "$external_prefixless_tag" "/tmp/${ZIP_NAME}" --repo "${external_repo}"

            #
            # Pod repo update
            #
            if [ "$key" = "cam" ]; then
              POD_REPO="lepsHub/CameraSDK-pod"
              PODSPEC_NAME="sdk-camera.podspec"
            else
              POD_REPO="lepsHub/CoreSDK-pod"
              PODSPEC_NAME="sdk-core.podspec"
            fi

            rm -rf /tmp/podrepo
            git clone "https://${{ secrets.GH_EXTERNAL_PAT }}@github.com/${POD_REPO}.git" /tmp/podrepo
            cd /tmp/podrepo

            git config user.name "luis[bot]"
            git config user.email "luis[bot]@users.noreply.github.com"

            rm -rf *.xcframework || true
            cp "/tmp/${ZIP_NAME}" .
            unzip "/tmp/${ZIP_NAME}" || true

            if [ -f "../${PODSPEC_NAME}" ]; then
              cp "../${PODSPEC_NAME}" .
            fi

            sed -i '' "s/spec.version *= *'.*'/spec.version = '$external_prefixless_tag'/" "$PODSPEC_NAME"

            git checkout -b "$external_prefixless_tag" || git checkout "$external_prefixless_tag"
            git add .
            if ! git diff --cached --quiet; then
              git commit -m "Release $external_prefixless_tag"
            fi

            git tag "$external_prefixless_tag" || true
            git push "https://${{ secrets.GH_EXTERNAL_PAT }}@github.com/${POD_REPO}.git" "refs/heads/${external_prefixless_tag}"
            git push "https://${{ secrets.GH_EXTERNAL_PAT }}@github.com/${POD_REPO}.git" "refs/tags/${external_prefixless_tag}"

            gh api -X POST "repos/${POD_REPO}/releases" \
              -f tag_name="$external_prefixless_tag" \
              -f name="$external_prefixless_tag" \
              -f body="$body" \
              -F prerelease=$prerelease >/dev/null

            gh release upload "$external_prefixless_tag" "/tmp/${ZIP_NAME}" --repo "${POD_REPO}" || true
            gh release upload "$external_prefixless_tag" "$PODSPEC_NAME" --repo "${POD_REPO}" || true

            cd -

            #
            # SPM repo update
            #
            if [ "$key" = "cam" ]; then
              SPM_REPO="lepsHub/PublicCameraSDK"
              PACKAGE_FILE="Package.swift"
              BINARY_NAME="CameraSDK"
            else
              SPM_REPO="lepsHub/PublicCoreSDK"
              PACKAGE_FILE="Package.swift"
              BINARY_NAME="CoreSDK"
            fi

            rm -rf /tmp/spm
            git clone "https://${{ secrets.GH_EXTERNAL_PAT }}@github.com/${SPM_REPO}.git" /tmp/spm
            cd /tmp/spm

            git config user.name "luis[bot]"
            git config user.email "luis[bot]@users.noreply.github.com"

            curl -L -o "/tmp/${ZIP_NAME}" "https://github.com/${external_repo}/releases/download/${external_prefixless_tag}/${ZIP_NAME}"
            CHECKSUM=$(swift package compute-checksum "/tmp/${ZIP_NAME}")

            cat > "$PACKAGE_FILE" <<EOF
            // swift-tools-version:5.8

            import PackageDescription

            let package = Package(
            name: "${BINARY_NAME}",
            products: [
                .library(name: "${BINARY_NAME}", targets: ["${BINARY_NAME}Targets"])
            ],
            targets: [
                .binaryTarget(
                name: "${BINARY_NAME}",
                url: "https://github.com/${external_repo}/releases/download/${external_prefixless_tag}/${ZIP_NAME}",
                checksum: "${CHECKSUM}"
                ),
                .target(name: "${BINARY_NAME}Targets", dependencies: ["${BINARY_NAME}"], path: "Sources")
            ]
            )
            EOF

            git checkout -b "$external_prefixless_tag" || git checkout "$external_prefixless_tag"
            git add "$PACKAGE_FILE"
            if ! git diff --cached --quiet; then
              git commit -m "SPM: Update Package.swift for $external_prefixless_tag"
            fi

            git push "https://${{ secrets.GH_EXTERNAL_PAT }}@github.com/${SPM_REPO}.git" "refs/heads/${external_prefixless_tag}"
            git tag "$external_prefixless_tag" || true
            git push "https://${{ secrets.GH_EXTERNAL_PAT }}@github.com/${SPM_REPO}.git" "refs/tags/${external_prefixless_tag}"

            gh api -X POST "repos/${SPM_REPO}/releases" \
              -f tag_name="$external_prefixless_tag" \
              -f name="$external_prefixless_tag" \
              -f body="$body" \
              -F prerelease=$prerelease >/dev/null

            cd -
          }

          #
          # MAIN LOOP
          #
          for fw in ${{ inputs.frameworks }}; do
            for ct in $(echo "$cut" | tr ',' ' '); do
              echo ">>> Processing: framework=$fw cut=$ct"
              cut_for "$fw" "$ct"
            done
          done
