name: Cut Release

on:
  pull_request:
    types: [closed]
    branches:
      - 'release/*'
  workflow_dispatch:
    inputs:
      cut:
        description: "Release type"
        type: choice
        options: [beta, rc, prod]
        required: false
      frameworks:
        description: "Which SDK(s) to cut"
        type: choice
        options: [camera, core, all]
        required: false
      dry_run:
        description: "Preview only (no tag/release)"
        type: boolean
        default: false
        required: false

permissions:
  contents: write
  pull-requests: read

concurrency:
  group: cut-release-${{ github.ref }}
  cancel-in-progress: false

jobs:
  cut_release:
    if: |
      (github.event_name == 'pull_request' && github.event.pull_request.merged == true) ||
      (github.event_name == 'workflow_dispatch')
    runs-on: macos-15

    env:
      LBL_BETA: cut-beta
      LBL_RC: cut-rc

      LBL_CAM: CameraSDK
      LBL_CORE: CoreSDK

      TAGPFX_CAM: 'CameraSDK'
      TAGPFX_CORE: 'CoreSDK'

      CHANNEL_PLIST_KEY: 'TRVReleaseChannel'

      GH_TOKEN: ${{ github.token }}

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Tooling / Git identity
        run: |
          brew update >/dev/null
          brew install jq xcodegen >/dev/null || true
          git config user.name  "truvideo[bot]"
          git config user.email "truvideo[bot]@users.noreply.github.com"

      - name: Resolve cut type and frameworks (manual > labels > paths)
        id: scope
        shell: bash
        run: |
          set -eo pipefail
          labels="$(jq -r '.pull_request.labels[].name // empty' <<< "${{ toJson(github.event) }}" 2>/dev/null || true)"

          # --- CUT TYPE: prod only manual; beta/rc manual or labels ---
          cut=""
          if [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ -n "${{ github.event.inputs.cut }}" ]; then
            cut="${{ github.event.inputs.cut }}"
          else
            has_beta=false
            has_rc=false
            grep -qx "${{ env.LBL_BETA }}" <<< "$labels" && has_beta=true
            grep -qx "${{ env.LBL_RC }}" <<< "$labels" && has_rc=true

            if [ "$has_beta" = true ] && [ "$has_rc" = true ]; then
              cut="beta,rc"
            elif [ "$has_beta" = true ]; then
              cut="beta"
            elif [ "$has_rc" = true ]; then
              cut="rc"
            fi
          fi
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            if [ -z "$cut" ] || [ "$cut" = "prod" ]; then
              echo "cut=" >> $GITHUB_OUTPUT; exit 0
            fi
          fi
          if [ -z "$cut" ]; then echo "cut=" >> $GITHUB_OUTPUT; exit 0; fi          
          allow=""
          if [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ -n "${{ github.event.inputs.frameworks }}" ]; then
            case "${{ github.event.inputs.frameworks }}" in
              camera) allow="cam" ;;
              core)   allow="core" ;;
              all)    allow="cam core" ;;
            esac
          else
            grep -qx "${{ env.LBL_CAM }}"  <<< "$labels" && allow="${allow} cam"  || true
            grep -qx "${{ env.LBL_CORE }}" <<< "$labels" && allow="${allow} core" || true
            allow="$(echo "$allow" | xargs)"
          fi

          final="$allow"; final="$(echo "$final" | xargs)"

          echo "cut=$cut" >> $GITHUB_OUTPUT
          echo "aff=$final" >> $GITHUB_OUTPUT
          echo "dry=${{ github.event.inputs.dry_run }}" >> $GITHUB_OUTPUT

      - name: Generate Xcode project
        if: ${{ steps.scope.outputs.aff != '' }}
        run: |
          set -eo pipefail
          make genbuild
          if [ -f "CoreSDK.xcodeproj/project.pbxproj" ]; then
            proj="CoreSDK.xcodeproj"
          else
            proj=$(ls -1 *.xcodeproj 2>/dev/null | head -n1 || true)
          fi
          if [ -z "$proj" ]; then
            echo "No .xcodeproj found after make genbuild"; exit 1
          fi
          echo "PROJECT=$proj" >> $GITHUB_ENV
          echo "Using PROJECT=$proj"

      - name: Compute versions, update Info.plist, generate Version.swift, tag & release
        if: ${{ steps.scope.outputs.cut != '' && steps.scope.outputs.aff != '' }}
        shell: bash
        run: |
          set -euo pipefail
          set -x
          trap 'echo "âŒ Error at line $LINENO: $BASH_COMMAND"' ERR

          cut="${{ steps.scope.outputs.cut }}"
          dry="${{ steps.scope.outputs.dry }}"

          find_plists () { git ls-files "$1" | grep -E '/Info\.plist$' || true; }
          read_short_ver () { /usr/libexec/PlistBuddy -c "Print :CFBundleShortVersionString" "$1" 2>/dev/null || true; }
          write_short_ver () { /usr/libexec/PlistBuddy -c "Set :CFBundleShortVersionString $2" "$1" || /usr/libexec/PlistBuddy -c "Add :CFBundleShortVersionString string $2" "$1"; }
          write_build_num () { /usr/libexec/PlistBuddy -c "Set :CFBundleVersion $2" "$1" || /usr/libexec/PlistBuddy -c "Add :CFBundleVersion string $2" "$1"; }
          write_channel_key () {
            local plist="$1" val="$2" key="${{ env.CHANNEL_PLIST_KEY }}"
            /usr/libexec/PlistBuddy -c "Set :$key $val" "$plist" \
              || /usr/libexec/PlistBuddy -c "Add :$key string $val" "$plist"
          }

          bump_from_commits () {
            local last_prod="$1" range="$2" bump="patch"
            if git log --format=%B $range | grep -Eq 'BREAKING CHANGE|!:'; then bump="major"
            elif git log --format=%s $range | grep -Eq '^feat(\(|:)|^feat!'; then bump="minor"
            elif git log --format=%s $range | grep -Eq '^fix(\(|:)|^fix!|^perf(\(|:)|^perf!'; then bump="patch"
            else bump="patch"; fi
            if [ -z "$last_prod" ]; then echo "0.1.0"; return; fi
            base="${last_prod##*-}"
            IFS='.' read -r major minor patch <<< "$base"
            case "$bump" in
              major) major=$((major+1)); minor=0; patch=0 ;;
              minor) minor=$((minor+1)); patch=0 ;;
              patch) patch=$((patch+1)) ;;
            esac
            echo "${major}.${minor}.${patch}"
          }

          next_beta_n () {
            local prefix="$1" base="$2" max=0
            while read -r t; do [ -z "$t" ] && continue
              n="${t##*.}"; [[ "$n" =~ ^[0-9]+$ ]] && [ "$n" -gt "$max" ] && max="$n" || true
            done < <(git tag -l "${prefix}-${base}-BETA.*")
            echo $((max+1))
          }

          last_beta_n () {
            local prefix="$1" base="$2" max=0
            while read -r t; do [ -z "$t" ] && continue
              n="${t##*.}"; [[ "$n" =~ ^[0-9]+$ ]] && [ "$n" -gt "$max" ] && max="$n" || true
            done < <(git tag -l "${prefix}-${base}-BETA.*")
            echo "$max"
          }

          next_rc_n () {
            local prefix="$1" base="$2" max=0
            while read -r t; do [ -z "$t" ] && continue
              n="${t##*.}"; [[ "$n" =~ ^[0-9]+$ ]] && [ "$n" -gt "$max" ] && max="$n" || true
            done < <(git tag -l "${prefix}-${base}-RC.*")
            echo $((max+1))
          }

          last_rc_n () {
            local prefix="$1" base="$2" max=0
            while read -r t; do [ -z "$t" ] && continue
              n="${t##*.}"; [[ "$n" =~ ^[0-9]+$ ]] && [ "$n" -gt "$max" ] && max="$n" || true
            done < <(git tag -l "${prefix}-${base}-RC.*")
            echo "$max"
          }

          rc_build_for_base () {
            local prefix="$1" base="$2"
            local bmax rmax
            bmax="$(last_beta_n "$prefix" "$base")"
            rmax="$(last_rc_n  "$prefix" "$base")"
            [ "$bmax" -ge "$rmax" ] && echo $((bmax + 1)) || echo $((rmax + 1))
          }

          latest_build_for_base () {
            local prefix="$1" base="$2" max=0
            while read -r t; do [ -z "$t" ] && continue
              n="${t##*.}"; [[ "$n" =~ ^[0-9]+$ ]] && [ "$n" -gt "$max" ] && max="$n" || true
            done < <( { git tag -l "${prefix}-${base}-BETA.*"; git tag -l "${prefix}-${base}-RC.*"; } )
            echo "$max"
          }
          
          next_global_build_number() {
            local prefix="$1" base="$2" max=0
            while read -r t; do
              [ -z "$t" ] && continue
              n="${t##*.}"
              [[ "$n" =~ ^[0-9]+$ ]] && [ "$n" -gt "$max" ] && max="$n"
              if [[ "$n" =~ ^[0-9]+$ ]]; then
                [ "$n" -gt "$max" ] && max="$n" || true
              fi
            done < <(
              git tag -l "${prefix}-${base}-BETA.*"
              git tag -l "${prefix}-${base}-RC.*"
            )
            echo $((max + 1))
          }

          gen_version_swift () {
            local destdir="$1" full="$2" channel="$3" build="$4"
            mkdir -p "$destdir"
            cat > "$destdir/Version.swift" <<SWIFT
          // Generated by CI â€“ do not edit.
          public let SDKVersionNumber: String = "$full"
          public let SDKEnvironment:   String = "$channel"
          public let SDKBuildNumber:   String = "$build"
          SWIFT
          }

          gen_changelog_md () {
            local range="$1" path="$2"
            local feats="" fixes="" perfs="" refacs="" docs="" tests="" build="" ci="" chores="" breaks=""
            while IFS= read -r s; do
              [ -z "$s" ] && continue
              [[ "$s" =~ BREAKING\ CHANGE|!\: ]] && breaks="${breaks}"$'\n- '"$s"
              if   [[ "$s" =~ ^feat(\(|:|\!) ]];      then feats="${feats}"$'\n- '"$s"
              elif [[ "$s" =~ ^fix(\(|:|\!) ]];       then fixes="${fixes}"$'\n- '"$s"
              elif [[ "$s" =~ ^perf(\(|:|\!) ]];      then perfs="${perfs}"$'\n- '"$s"
              elif [[ "$s" =~ ^refactor(\(|:|\!) ]];  then refacs="${refacs}"$'\n- '"$s"
              elif [[ "$s" =~ ^docs(\(|:|\!) ]];      then docs="${docs}"$'\n- '"$s"
              elif [[ "$s" =~ ^test(\(|:|\!) ]];      then tests="${tests}"$'\n- '"$s"
              elif [[ "$s" =~ ^build(\(|:|\!) ]];     then build="${build}"$'\n- '"$s"
              elif [[ "$s" =~ ^ci(\(|:|\!) ]];        then ci="${ci}"$'\n- '"$s"
              elif [[ "$s" =~ ^chore(\(|:|\!) ]];     then chores="${chores}"$'\n- '"$s"
              fi
            done < <(git log --pretty=format:'%s' $range -- "$path" || true)
            {
              echo "## Changes"
              [ -n "$breaks" ] && { echo; echo "### âš ï¸ Breaking Changes"; echo "$breaks"; }
              [ -n "$feats"  ] && { echo; echo "### âœ¨ Features";        echo "$feats"; }
              [ -n "$fixes"  ] && { echo; echo "### ðŸ› Fixes";           echo "$fixes"; }
              [ -n "$perfs"  ] && { echo; echo "### ðŸš€ Performance";     echo "$perfs"; }
              [ -n "$refacs" ] && { echo; echo "### ðŸ§¹ Refactors";       echo "$refacs"; }
              [ -n "$docs"   ] && { echo; echo "### ðŸ“ Docs";            echo "$docs"; }
              [ -n "$tests"  ] && { echo; echo "### âœ… Tests";           echo "$tests"; }
              [ -n "$build"  ] && { echo; echo "### ðŸ§± Build";           echo "$build"; }
              [ -n "$ci"     ] && { echo; echo "### âš™ï¸ CI";              echo "$ci"; }
              [ -n "$chores" ] && { echo; echo "### ðŸ§° Chore";           echo "$chores"; }
            } | sed '/^$/N;/^\n$/D' || true
          }

          cut_for () {
            local key="$1" cut_type="$2" prefix path vdir channel full base_ver build_num prerelease title
            
            # Framework configuration - easily extensible
            # Format: "key:prefix:path:vdir"
            case "$key" in
              "cam")
                prefix="${{ env.TAGPFX_CAM }}"
                path="Libraries/Plugins/Camera/"
                vdir="Sources/CameraSDK/Generated"
                ;;
              "core")
                prefix="${{ env.TAGPFX_CORE }}"
                path="Libraries/External/Extended/App/"
                vdir="Sources/CoreSDK/Generated"
                ;;
              *)
                echo "Error: Unknown framework key '$key'"
                echo "Available keys: cam, core"
                exit 1
                ;;
            esac

            # Only consider final prod tags for base version
            last_prod=$(
              git tag -l "${prefix}-*" --sort=-v:refname \
              | grep -E "^${prefix}-[0-9]+\.[0-9]+\.[0-9]+$" \
              | head -n1
            )

            since_ref=""; [ -n "$last_prod" ] && since_ref="$(git rev-list -n1 "$last_prod")"
            range="${since_ref:+${since_ref}..}HEAD"

            base_ver="$(bump_from_commits "$last_prod" "${range:-HEAD}")"

            if [ "$cut_type" = "beta" ]; then
              channel="BETA"
              build_num="$(next_global_build_number "$prefix" "$base_ver")"
              full="${base_ver}-BETA.${build_num}"
              prerelease="true"
              title="Internal BETA release for **$prefix $base_ver**."
            elif [ "$cut_type" = "rc" ]; then
              channel="RC"
              build_num="$(next_global_build_number "$prefix" "$base_ver")"
              full="${base_ver}-RC.${build_num}"
              prerelease="true"
              title="Release Candidate for **$prefix $base_ver**."
            else
              channel="PROD"
              full="${base_ver}"
              bn="$(next_global_build_number "$prefix" "$base_ver")"
              [ "$bn" -gt 0 ] && build_num="$bn" || build_num="1"
              prerelease="false"
              title="Production release for **$prefix $base_ver**."
            fi
            
            while read -r plist; do
              [ -z "$plist" ] && continue
              cur_short="$(read_short_ver "$plist")"
              if [ "$cur_short" != "$base_ver" ]; then write_short_ver "$plist" "$base_ver"; fi
              write_build_num "$plist" "$build_num"
              write_channel_key "$plist" "$channel"
            done < <(find_plists "$path")
            
            gen_version_swift "$vdir" "$full" "$channel" "$build_num"

            # Changelog body (since last prod)
            chg="$(gen_changelog_md "$range" "$path")"

            body_header=$(printf '%s\n' \
              "%TITLE%" \
              "" \
              "- **CFBundleShortVersionString**: %BASE%" \
              "- **CFBundleVersion**: %BUILD%" \
              "- **SdkVersionNumber**: %FULL%" \
              "- **Channel**: %CHANNEL%" \
              "" \
              "%CHANGELOG%")
            body="${body_header//%TITLE%/$title}"
            body="${body//%BASE%/$base_ver}"
            body="${body//%BUILD%/$build_num}"
            body="${body//%FULL%/$full}"
            body="${body//%CHANNEL%/$channel}"
            body="${body//%CHANGELOG%/$chg}"

            tag="${prefix}-${full}"

            if [ "$dry" = "true" ]; then
              echo "[DRY RUN] Would tag: $tag"
              echo "[DRY RUN] Would create release:"; echo "$body"
              return 0
            fi            
            git add "$path" || true
            if [ -f "$vdir/Version.swift" ] && ! git check-ignore -q "$vdir/Version.swift"; then
              git add "$vdir/Version.swift"
            fi
            if ! git diff --cached --quiet; then
              git commit -m "chore(release): bump ${prefix} to ${full} (${channel})"
            fi

            external_repo=""
            external_prefixless_tag="$full"

            if [ "$key" = "cam" ]; then
              external_repo="lepsHub/PublicCameraSDK"
            elif [ "$key" = "core" ]; then
              external_repo="lepsHub/PublicCoreSDK"
            fi

            if [ -z "$external_repo" ]; then
              echo "ERROR: unknown external repo for key '$key'"
              exit 1
            fi

            echo "== Building XCFramework for $key =="
            # Build XCFramework (archives for device + simulator, then create XCFramework)
            if [ "$key" = "cam" ]; then
              SCHEME="CameraSDK"
              XC_OUTPUT="build/CameraSDK.xcframework"
            else
              SCHEME="CoreSDK"
              XC_OUTPUT="build/CoreSDK.xcframework"
            fi

            mkdir -p build
            set -x
            xcodebuild archive -scheme "$SCHEME" -destination "generic/platform=iOS" -archivePath build/ios.xcarchive SKIP_INSTALL=NO BUILD_LIBRARY_FOR_DISTRIBUTION=YES
            xcodebuild archive -scheme "$SCHEME" -destination "generic/platform=iOS Simulator" -archivePath build/sim.xcarchive SKIP_INSTALL=NO BUILD_LIBRARY_FOR_DISTRIBUTION=YES
            xcodebuild -create-xcframework \
              -framework "build/ios.xcarchive/Products/Library/Frameworks/${SCHEME}.framework" \
              -framework "build/sim.xcarchive/Products/Library/Frameworks/${SCHEME}.framework" \
              -output "$XC_OUTPUT"
            set +x

            if [ ! -d "$XC_OUTPUT" ]; then
              echo "ERROR: xcframework not found at $XC_OUTPUT"
              exit 1
            fi

            echo "== Creating external lightweight tag: $external_prefixless_tag on $external_repo =="
            # create lightweight external tag locally
            git tag "$external_prefixless_tag" || true

            # push tag to external repo
            git push "https://${{ secrets.GH_EXTERNAL_PAT }}@github.com/${external_repo}.git" "refs/tags/${external_prefixless_tag}" || {
              echo "ERROR pushing external tag to ${external_repo}"
              exit 1
            }

            echo "== Creating release on external repo: $external_repo and uploading artifacts =="
            # create a release and upload xcframework zip
            ZIP_NAME="${external_prefixless_tag}-${key}.xcframework.zip"
            rm -f "/tmp/${ZIP_NAME}"
            (cd $(dirname "$XC_OUTPUT") && zip -r "/tmp/${ZIP_NAME}" "$(basename "$XC_OUTPUT")")

            gh api \
              -X POST \
              "repos/${external_repo}/releases" \
              -f tag_name="$external_prefixless_tag" \
              -f name="$external_prefixless_tag" \
              -f body="$body" \
              -F prerelease=$prerelease \
              >/dev/null

            # upload artifact (xcframework zip)
            gh release upload "$external_prefixless_tag" "/tmp/${ZIP_NAME}" --repo "${external_repo}" || {
              echo "WARN: failed to upload xcframework zip to release ${external_prefixless_tag} in ${external_repo}"
            }

            echo "External release created for $external_repo"

            #
            # --- Publish to Pod Repo (clone, update podspec, push tag & release with podspec + xcframework) ---
            #
            if [ "$key" = "cam" ]; then
              POD_REPO="lepsHub/CameraSDK-pod"
              PODSPEC_NAME="sdk-camera.podspec"
            else
              POD_REPO="lepsHub/CoreSDK-pod"
              PODSPEC_NAME="sdk-core.podspec"
            fi

            echo "== Preparing Pod repo $POD_REPO =="
            rm -rf /tmp/podrepo || true
            git clone "https://${{ secrets.GH_EXTERNAL_PAT }}@github.com/${POD_REPO}.git" /tmp/podrepo
            cd /tmp/podrepo
            git config user.name "luis[bot]"
            git config user.email "luis[bot]@users.noreply.github.com"

            # copy xcframework and podspec
            rm -rf CoreSDK*.xcframework || true
            cp -R "${XC_OUTPUT}" .
            if [ -f "../${PODSPEC_NAME}" ]; then
              cp "../${PODSPEC_NAME}" . || true
            fi

            # update podspec version line (simple sed)
            sed -i '' "s/spec.version *= *'.*'/spec.version = '$external_prefixless_tag'/" "$PODSPEC_NAME" || true

            # create branch named as version and commit
            git checkout -b "$external_prefixless_tag" || git checkout "$external_prefixless_tag" || true
            git add .
            if ! git diff --cached --quiet; then
              git commit -m "Release $external_prefixless_tag"
            fi

            # create and push tag (lightweight) on pod repo
            git tag "$external_prefixless_tag" || true
            git push "https://${{ secrets.GH_EXTERNAL_PAT }}@github.com/${POD_REPO}.git" "refs/heads/${external_prefixless_tag}:refs/heads/${external_prefixless_tag}" || true
            git push "https://${{ secrets.GH_EXTERNAL_PAT }}@github.com/${POD_REPO}.git" "refs/tags/${external_prefixless_tag}" || {
              echo "ERROR pushing tag to pod repo ${POD_REPO}"
              exit 1
            }

            echo "== Creating release on Pod repo ${POD_REPO} =="
            gh api -X POST "repos/${POD_REPO}/releases" \
              -f tag_name="$external_prefixless_tag" \
              -f name="$external_prefixless_tag" \
              -f body="$body" \
              -F prerelease=$prerelease >/dev/null

            # upload xcframework and podspec to pod release
            gh release upload "$external_prefixless_tag" "${XC_OUTPUT}.zip" --repo "${POD_REPO}" 2>/dev/null || true
            # also upload the podspec
            gh release upload "$external_prefixless_tag" "$PODSPEC_NAME" --repo "${POD_REPO}" 2>/dev/null || true
            echo "Pod repo release created for ${POD_REPO}"

            #
            # Try pod trunk push (if using public cocoapods trunk). This requires COCOAPODS_TRUNK_TOKEN be configured.
            #
            if [ -n "${COCOAPODS_TRUNK_TOKEN:-}" ]; then
              echo "Attempting pod trunk push for $PODSPEC_NAME (version $external_prefixless_tag)"
              MAX_RETRIES=3
              RETRY_DELAY=30
              ATTEMPT=1
              while [ $ATTEMPT -le $MAX_RETRIES ]; do
                echo "pod trunk push attempt $ATTEMPT"
                pod trunk push "$PODSPEC_NAME" --allow-warnings && break
                echo "pod trunk push failed; sleeping $RETRY_DELAY"
                sleep $RETRY_DELAY
                ATTEMPT=$((ATTEMPT+1))
              done
              if [ $ATTEMPT -gt $MAX_RETRIES ]; then
                echo "WARNING: pod trunk push did not succeed after $MAX_RETRIES attempts"
              fi
            else
              echo "COCOAPODS_TRUNK_TOKEN not set; skipping pod trunk push (only updated pod repo)."
            fi

            #
            # --- Update SPM repo (Package.swift) ---
            #
            if [ "$key" = "cam" ]; then
              SPM_REPO="lepsHub/PublicCameraSDK"
              PACKAGE_FILE="Package.swift"
              BINARY_NAME="CameraSDK"
            else
              SPM_REPO="lepsHub/PublicCoreSDK"
              PACKAGE_FILE="Package.swift"
              BINARY_NAME="CoreSDK"
            fi

            echo "== Updating SPM repo ${SPM_REPO} =="
            rm -rf /tmp/spm || true
            git clone "https://${{ secrets.GH_EXTERNAL_PAT }}@github.com/${SPM_REPO}.git" /tmp/spm
            cd /tmp/spm
            git config user.name "luis[bot]"
            git config user.email "luis[bot]@users.noreply.github.com"

            # prepare zip for download URL in Package.swift
            RELEASE_ZIP_NAME="${external_prefixless_tag}-${key}.xcframework.zip"
            # ensure release zip exists in external repo (it should have been uploaded above)
            # compute checksum (use swift tool if available)
            if command -v swift >/dev/null 2>&1; then
              curl -L -o "/tmp/${RELEASE_ZIP_NAME}" "https://github.com/${external_repo}/releases/download/${external_prefixless_tag}/${ZIP_NAME}" || true
              CHECKSUM=$(swift package compute-checksum "/tmp/${RELEASE_ZIP_NAME}" 2>/dev/null || true)
            else
              # fallback: sha256
              curl -L -o "/tmp/${RELEASE_ZIP_NAME}" "https://github.com/${external_repo}/releases/download/${external_prefixless_tag}/${ZIP_NAME}" || true
              CHECKSUM=$(shasum -a 256 "/tmp/${RELEASE_ZIP_NAME}" | awk '{print $1}')
            fi

            PACKAGE_CONTENT="// swift-tools-version:5.8

            import PackageDescription
                        
            let package = Package(
              name: \"${BINARY_NAME}\",
              products: [
                .library(name: \"${BINARY_NAME}\", targets: [\"${BINARY_NAME}Targets\"])
              ],
              targets: [
                .binaryTarget(
                  name: \"${BINARY_NAME}\",
                  url: \"https://github.com/${external_repo}/releases/download/${external_prefixless_tag}/${ZIP_NAME}\",
                  checksum: \"${CHECKSUM}\"
                ),
                .target(name: \"${BINARY_NAME}Targets\", dependencies: [\"${BINARY_NAME}\"], path: \"Sources\")
              ]
            )
            "
            echo "$PACKAGE_CONTENT" > "$PACKAGE_FILE"
            if git show-ref --verify --quiet "refs/heads/$external_prefixless_tag"; then
              git checkout "$external_prefixless_tag"
            else
              git checkout -b "$external_prefixless_tag"
            fi
            git add "$PACKAGE_FILE"
            if ! git diff --cached --quiet; then
              git commit -m "SPM: Update Package.swift for $external_prefixless_tag"
            fi
            git push "https://${{ secrets.GH_EXTERNAL_PAT }}@github.com/${SPM_REPO}.git" "refs/heads/${external_prefixless_tag}" || true
            git tag "$external_prefixless_tag" || true
            git push "https://${{ secrets.GH_EXTERNAL_PAT }}@github.com/${SPM_REPO}.git" "refs/tags/${external_prefixless_tag}" || true
            gh api -X POST "repos/${SPM_REPO}/releases" -f tag_name="$external_prefixless_tag" -f name="$external_prefixless_tag" -f body="$body" -F prerelease=$prerelease >/dev/null || true
            echo "SPM repo updated: ${SPM_REPO}"
          }

          for s in ${{ steps.scope.outputs.aff }}; do
            for cut_type in $(echo "${{ steps.scope.outputs.cut }}" | tr ',' ' '); do
              cut_for "$s" "$cut_type"
            done
          done
