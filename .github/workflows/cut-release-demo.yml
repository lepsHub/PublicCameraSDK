name: Cut Release Demo

on:
  pull_request:
    types: [closed]
    branches:
      - 'release/*'
  workflow_dispatch:
    inputs:
      cut:
        description: "Release type"
        type: choice
        options: [beta, rc, prod]
        required: false
      frameworks:
        description: "Which SDK(s) to cut"
        type: choice
        options: [camera, core, all]
        required: false
      dry_run:
        description: "Preview only (no tag/release)"
        type: boolean
        default: false
        required: false

permissions:
  contents: write
  pull-requests: read

concurrency:
  group: cut-release-${{ github.ref }}
  cancel-in-progress: false

jobs:
  cut_release:
    if: |
      (github.event_name == 'pull_request' && github.event.pull_request.merged == true) ||
      (github.event_name == 'workflow_dispatch')
    runs-on: macos-15

    env:
      LBL_BETA: cut-beta
      LBL_RC: cut-rc

      LBL_CAM: CameraSDK
      LBL_CORE: CoreSDK

      TAGPFX_CAM: 'CameraSDK'
      TAGPFX_CORE: 'CoreSDK'

      CHANNEL_PLIST_KEY: 'TRVReleaseChannel'

      GH_TOKEN: ${{ secrets.GH_EXTERNAL_PAT }}

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GH_EXTERNAL_PAT }}

      - name: Tooling / Git identity
        run: |
          brew update >/dev/null
          brew install jq xcodegen >/dev/null || true
          git config user.name  "truvideo[bot]"
          git config user.email "truvideo[bot]@users.noreply.github.com"

      - name: Resolve cut type and frameworks (manual > labels > paths)
        id: scope
        shell: bash
        run: |
          set -eo pipefail

          # Extract labels safely (one per line)
          labels="$(jq -r '.pull_request.labels[].name // empty' "$GITHUB_EVENT_PATH" 2>/dev/null | sed '/^\s*$/d')"

          # Trim safely removing double spaces, leading/trailing
          safe_trim() {
            printf "%s" "$1" | tr -s ' ' | sed 's/^ //; s/ $//'
          }

          # Ensure aff has valid values only
          sanitize_aff() {
            case "$1" in
              cam) echo "cam" ;;
              core) echo "core" ;;
              "cam core"|"core cam") echo "cam core" ;;
              *) echo "" ;;
            esac
          }

          # ---------------------------
          # CUT TYPE
          # ---------------------------
          cut=""
          if [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ -n "${{ github.event.inputs.cut }}" ]; then
            cut="${{ github.event.inputs.cut }}"
          else
            if grep -Fxq "${{ env.LBL_BETA }}" <<< "$labels"; then
              cut="beta"
            fi
            if grep -Fxq "${{ env.LBL_RC }}" <<< "$labels"; then
              cut="rc"
            fi
            if grep -Fxq "${{ env.LBL_PROD }}" <<< "$labels"; then
              cut="prod"
            fi
          fi

          if [ -z "$cut" ]; then
            echo "cut=" >> $GITHUB_OUTPUT
            echo "aff=" >> $GITHUB_OUTPUT
            echo "dry=" >> $GITHUB_OUTPUT
            exit 0
          fi

          # ---------------------------
          # FRAMEWORKS (AFF)
          # ---------------------------
          allow=""
          if [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ -n "${{ github.event.inputs.frameworks }}" ]; then
            case "${{ github.event.inputs.frameworks }}" in
              camera) allow="cam" ;;
              core) allow="core" ;;
              all) allow="cam core" ;;
            esac
          else
            if grep -Fxq "${{ env.LBL_CAM }}" <<< "$labels"; then
              allow="$allow cam"
            fi
            if grep -Fxq "${{ env.LBL_CORE }}" <<< "$labels"; then
              allow="$allow core"
            fi
          fi

          allow="$(safe_trim "$allow")"
          final="$(sanitize_aff "$allow")"

          echo "cut=$cut" >> $GITHUB_OUTPUT
          echo "aff=$final" >> $GITHUB_OUTPUT
          echo "dry=${{ github.event.inputs.dry_run }}" >> $GITHUB_OUTPUT
      - name: Reset SwiftPM caches
        run: |
            rm -rf ~/Library/Caches/org.swift.swiftpm
      - name: Generate Xcode project
        if: ${{ steps.scope.outputs.aff != '' }}
        run: |
          set -eo pipefail
          make genbuild
          if [ -f "TruvideoSDK.xcodeproj/project.pbxproj" ]; then
            proj="TruvideoSDK.xcodeproj"
          else
            proj=$(ls -1 *.xcodeproj 2>/dev/null | head -n1 || true)
          fi
          if [ -z "$proj" ]; then
            echo "No .xcodeproj found after make genbuild"; exit 1
          fi
          echo "PROJECT=$proj" >> $GITHUB_ENV
          echo "Using PROJECT=$proj"

      - name: Compute versions, update Info.plist, generate Version.swift, tag & release
        if: ${{ steps.scope.outputs.cut != '' && steps.scope.outputs.aff != '' }}
        shell: bash
        env:
          CUT: ${{ steps.scope.outputs.cut }}
          DRY: ${{ steps.scope.outputs.dry }}
        run: |
          set -eo pipefail

          cut="$CUT"
          dry="$DRY"

          find_plists () { git ls-files "$1" | grep -E '/Info\.plist$' || true; }
          read_short_ver () { /usr/libexec/PlistBuddy -c "Print :CFBundleShortVersionString" "$1" 2>/dev/null || true; }
          write_short_ver () { /usr/libexec/PlistBuddy -c "Set :CFBundleShortVersionString $2" "$1" || /usr/libexec/PlistBuddy -c "Add :CFBundleShortVersionString string $2" "$1"; }
          write_build_num () { /usr/libexec/PlistBuddy -c "Set :CFBundleVersion $2" "$1" || /usr/libexec/PlistBuddy -c "Add :CFBundleVersion string $2" "$1"; }
          write_channel_key () {
            local plist="$1" val="$2" key="${{ env.CHANNEL_PLIST_KEY }}"
            /usr/libexec/PlistBuddy -c "Set :$key $val" "$plist" \
              || /usr/libexec/PlistBuddy -c "Add :$key string $val" "$plist"
          }

          bump_from_commits () {
            local last_prod="$1" range="$2" bump="patch"
            if git log --format=%B $range | grep -Eq 'BREAKING CHANGE|!:'; then bump="major"
            elif git log --format=%s $range | grep -Eq '^feat(\(|:)|^feat!'; then bump="minor"
            elif git log --format=%s $range | grep -Eq '^fix(\(|:)|^fix!|^perf(\(|:)|^perf!'; then bump="patch"
            else bump="patch"; fi
            if [ -z "$last_prod" ]; then echo "0.1.0"; return; fi
            base="${last_prod##*-}"
            IFS='.' read -r major minor patch <<< "$base"
            case "$bump" in
              major) major=$((major+1)); minor=0; patch=0 ;;
              minor) minor=$((minor+1)); patch=0 ;;
              patch) patch=$((patch+1)) ;;
            esac
            echo "${major}.${minor}.${patch}"
            echo "[DEBUG bump] last_prod=$1" >&2
            echo "[DEBUG bump] range=$2" >&2
            git log --format='%h %s' $2 >&2
          }
          

          next_beta_n () {
            local prefix="$1" base="$2" max=0
            while read -r t; do [ -z "$t" ] && continue
              n="${t##*.}"; [[ "$n" =~ ^[0-9]+$ ]] && [ "$n" -gt "$max" ] && max="$n" || true
            done < <(git tag -l "${prefix}-${base}-BETA.*")
            echo $((max+1))
          }

          last_beta_n () {
            local prefix="$1" base="$2" max=0
            while read -r t; do [ -z "$t" ] && continue
              n="${t##*.}"; [[ "$n" =~ ^[0-9]+$ ]] && [ "$n" -gt "$max" ] && max="$n" || true
            done < <(git tag -l "${prefix}-${base}-BETA.*")
            echo "$max"
          }

          next_rc_n () {
            local prefix="$1" base="$2" max=0
            while read -r t; do [ -z "$t" ] && continue
              n="${t##*.}"; [[ "$n" =~ ^[0-9]+$ ]] && [ "$n" -gt "$max" ] && max="$n" || true
            done < <(git tag -l "${prefix}-${base}-RC.*")
            echo $((max+1))
          }

          last_rc_n () {
            local prefix="$1" base="$2" max=0
            while read -r t; do [ -z "$t" ] && continue
              n="${t##*.}"; [[ "$n" =~ ^[0-9]+$ ]] && [ "$n" -gt "$max" ] && max="$n" || true
            done < <(git tag -l "${prefix}-${base}-RC.*")
            echo "$max"
          }

          rc_build_for_base () {
            local prefix="$1" base="$2"
            local bmax rmax
            bmax="$(last_beta_n "$prefix" "$base")"
            rmax="$(last_rc_n  "$prefix" "$base")"
            [ "$bmax" -ge "$rmax" ] && echo $((bmax + 1)) || echo $((rmax + 1))
          }

          latest_build_for_base () {
            local prefix="$1" base="$2" max=0
            while read -r t; do [ -z "$t" ] && continue
              n="${t##*.}"; [[ "$n" =~ ^[0-9]+$ ]] && [ "$n" -gt "$max" ] && max="$n" || true
            done < <( { git tag -l "${prefix}-${base}-BETA.*"; git tag -l "${prefix}-${base}-RC.*"; } )
            echo "$max"
          }
          
          next_global_build_number() {
            local prefix="$1" base="$2" max=0
            while read -r t; do
              [ -z "$t" ] && continue
              n="${t##*.}"
              [[ "$n" =~ ^[0-9]+$ ]] && [ "$n" -gt "$max" ] && max="$n"
              if [[ "$n" =~ ^[0-9]+$ ]]; then
                [ "$n" -gt "$max" ] && max="$n" || true
              fi
            done < <(
              git tag -l "${prefix}-${base}-BETA.*"
              git tag -l "${prefix}-${base}-RC.*"
            )
            echo $((max + 1))
          }

          gen_version_swift () {
            local destdir="$1" full="$2" channel="$3" build="$4"
            mkdir -p "$destdir"
            cat > "$destdir/Version.swift" <<SWIFT
          // Generated by CI ‚Äì do not edit.
          public let SDKVersionNumber: String = "$full"
          public let SDKEnvironment:   String = "$channel"
          public let SDKBuildNumber:   String = "$build"
          SWIFT
          }

          gen_changelog_md () {
            local range="$1" path="$2"
            local feats="" fixes="" perfs="" refacs="" docs="" tests="" build="" ci="" chores="" breaks=""
            while IFS= read -r s; do
              [ -z "$s" ] && continue
              [[ "$s" =~ BREAKING\ CHANGE|!\: ]] && breaks="${breaks}"$'\n- '"$s"
              if   [[ "$s" =~ ^feat(\(|:|\!) ]];      then feats="${feats}"$'\n- '"$s"
              elif [[ "$s" =~ ^fix(\(|:|\!) ]];       then fixes="${fixes}"$'\n- '"$s"
              elif [[ "$s" =~ ^perf(\(|:|\!) ]];      then perfs="${perfs}"$'\n- '"$s"
              elif [[ "$s" =~ ^refactor(\(|:|\!) ]];  then refacs="${refacs}"$'\n- '"$s"
              elif [[ "$s" =~ ^docs(\(|:|\!) ]];      then docs="${docs}"$'\n- '"$s"
              elif [[ "$s" =~ ^test(\(|:|\!) ]];      then tests="${tests}"$'\n- '"$s"
              elif [[ "$s" =~ ^build(\(|:|\!) ]];     then build="${build}"$'\n- '"$s"
              elif [[ "$s" =~ ^ci(\(|:|\!) ]];        then ci="${ci}"$'\n- '"$s"
              elif [[ "$s" =~ ^chore(\(|:|\!) ]];     then chores="${chores}"$'\n- '"$s"
              fi
            done < <(git log --pretty=format:'%s' $range -- "$path" || true)
            {
              echo "## Changes"
              [ -n "$breaks" ] && { echo; echo "### ‚ö†Ô∏è Breaking Changes"; echo "$breaks"; }
              [ -n "$feats"  ] && { echo; echo "### ‚ú® Features";        echo "$feats"; }
              [ -n "$fixes"  ] && { echo; echo "### üêõ Fixes";           echo "$fixes"; }
              [ -n "$perfs"  ] && { echo; echo "### üöÄ Performance";     echo "$perfs"; }
              [ -n "$refacs" ] && { echo; echo "### üßπ Refactors";       echo "$refacs"; }
              [ -n "$docs"   ] && { echo; echo "### üìù Docs";            echo "$docs"; }
              [ -n "$tests"  ] && { echo; echo "### ‚úÖ Tests";           echo "$tests"; }
              [ -n "$build"  ] && { echo; echo "### üß± Build";           echo "$build"; }
              [ -n "$ci"     ] && { echo; echo "### ‚öôÔ∏è CI";              echo "$ci"; }
              [ -n "$chores" ] && { echo; echo "### üß∞ Chore";           echo "$chores"; }
            } | sed '/^$/N;/^\n$/D' || true
          }

          cut_for () {
            local key="$1" cut_type="$2" prefix path vdir channel full base_ver build_num prerelease title
            
            # Framework configuration - easily extensible
            # Format: "key:prefix:path:vdir"
            case "$key" in
              "cam")
                prefix="${{ env.TAGPFX_CAM }}"
                path="Libraries/Plugins/Camera/"
                vdir="Sources/TruvideoSdkCamera/Generated"
                ;;
              "core")
                prefix="${{ env.TAGPFX_CORE }}"
                path="Libraries/External/Extended/App/"
                vdir="Sources/TruvideoSdk/Generated"
                ;;
              *)
                echo "Error: Unknown framework key '$key'"
                echo "Available keys: cam, core"
                exit 1
                ;;
            esac

            # Only consider final prod tags for base version
            last_prod=$(
              git tag -l "${prefix}-*" --sort=-v:refname \
              | grep -E "^${prefix}-[0-9]+\.[0-9]+\.[0-9]+$" \
              | head -n1
            )

            since_ref=""; [ -n "$last_prod" ] && since_ref="$(git rev-list -n1 "$last_prod")"
            range="${since_ref:+${since_ref}..}HEAD"

            base_ver="$(bump_from_commits "$last_prod" "${range:-HEAD}")"

            if [ "$cut_type" = "beta" ]; then
              channel="BETA"
              build_num="$(next_global_build_number "$prefix" "$base_ver")"
              full="${base_ver}-BETA.${build_num}"
              prerelease="true"
              title="Internal BETA release for **$prefix $base_ver**."
            elif [ "$cut_type" = "rc" ]; then
              channel="RC"
              build_num="$(next_global_build_number "$prefix" "$base_ver")"
              full="${base_ver}-RC.${build_num}"
              prerelease="true"
              title="Release Candidate for **$prefix $base_ver**."
            else
              channel="PROD"
              full="${base_ver}"
              bn="$(next_global_build_number "$prefix" "$base_ver")"
              [ "$bn" -gt 0 ] && build_num="$bn" || build_num="1"
              prerelease="false"
              title="Production release for **$prefix $base_ver**."
            fi
            
            while read -r plist; do
              [ -z "$plist" ] && continue
              cur_short="$(read_short_ver "$plist")"
              if [ "$cur_short" != "$base_ver" ]; then write_short_ver "$plist" "$base_ver"; fi
              write_build_num "$plist" "$build_num"
              write_channel_key "$plist" "$channel"
            done < <(find_plists "$path")
            
            gen_version_swift "$vdir" "$full" "$channel" "$build_num"

            # Changelog body (since last prod)
            chg="$(gen_changelog_md "$range" "$path")"

            body_header=$(printf '%s\n' \
              "%TITLE%" \
              "" \
              "- **CFBundleShortVersionString**: %BASE%" \
              "- **CFBundleVersion**: %BUILD%" \
              "- **SdkVersionNumber**: %FULL%" \
              "- **Channel**: %CHANNEL%" \
              "" \
              "%CHANGELOG%")
            body="${body_header//%TITLE%/$title}"
            body="${body//%BASE%/$base_ver}"
            body="${body//%BUILD%/$build_num}"
            body="${body//%FULL%/$full}"
            body="${body//%CHANNEL%/$channel}"
            body="${body//%CHANGELOG%/$chg}"

            tag="${prefix}-${full}"

            if [ "$dry" = "true" ]; then
              echo "[DRY RUN] Would tag: $tag"
              echo "[DRY RUN] Would create release:"; echo "$body"
              return 0
            fi            
            git add "$path" || true
            if [ -f "$vdir/Version.swift" ] && ! git check-ignore -q "$vdir/Version.swift"; then
              git add "$vdir/Version.swift"
            fi
            if ! git diff --cached --quiet; then
              git commit -m "chore(release): bump ${prefix} to ${full} (${channel})"
            fi

            external_repo=""
            external_prefixless_tag="$full"

            if [ "$key" = "cam" ]; then
              external_repo="Truvideo/truvideo-sdk-ios-camera"
            elif [ "$key" = "core" ]; then
              external_repo="Truvideo/truvideo-sdk-ios-core"
            fi

            if [ -z "$external_repo" ]; then
              echo "ERROR: unknown external repo for key '$key'"
              exit 1
            fi

            echo "== Building XCFramework for $key =="
            # Build XCFramework (archives for device + simulator, then create XCFramework)
            if [ "$key" = "cam" ]; then
              SCHEME="TruvideoSdkCamera"
              XC_OUTPUT="build/TruvideoSdkCamera.xcframework"
            else
              SCHEME="TruvideoSdkCore"
              XC_OUTPUT="build/TruvideoSdkCore.xcframework"
            fi

            mkdir -p build
            set -x
            xcodebuild archive -scheme "$SCHEME" -destination "generic/platform=iOS" -archivePath build/ios.xcarchive SKIP_INSTALL=NO BUILD_LIBRARY_FOR_DISTRIBUTION=YES
            xcodebuild archive -scheme "$SCHEME" -destination "generic/platform=iOS Simulator" -archivePath build/sim.xcarchive SKIP_INSTALL=NO BUILD_LIBRARY_FOR_DISTRIBUTION=YES
            xcodebuild -create-xcframework \
              -framework "build/ios.xcarchive/Products/Library/Frameworks/${SCHEME}.framework" \
              -framework "build/sim.xcarchive/Products/Library/Frameworks/${SCHEME}.framework" \
              -output "$XC_OUTPUT"
            set +x

            if [ ! -d "$XC_OUTPUT" ]; then
              echo "ERROR: xcframework not found at $XC_OUTPUT"
              exit 1
            fi

              echo "== Creating external lightweight tag: ${external_prefixless_tag} on ${external_repo} =="

              AUTH_REPO_URL="https://${{ secrets.GH_EXTERNAL_PAT }}:x-oauth-basic@github.com/${external_repo}.git"
              PUSH_REPO_URL="https://${{ secrets.GH_EXTERNAL_PAT }}@github.com/${external_repo}.git"

              # Correct authenticated check
              if git ls-remote --tags "$AUTH_REPO_URL" | grep -q "refs/tags/${external_prefixless_tag}"; then
                  echo "‚ö†Ô∏è  Tag '${external_prefixless_tag}' already exists in ${external_repo}. Skipping tag creation."
              else
                  echo "‚û°Ô∏è  Tag '${external_prefixless_tag}' does not exist. Creating and pushing..."
                  git tag "${external_prefixless_tag}"
                  git push "$PUSH_REPO_URL" "refs/tags/${external_prefixless_tag}"
                  echo "‚úÖ  External tag '${external_prefixless_tag}' pushed successfully."
              fi

            echo "== Creating release on external repo: $external_repo and uploading artifacts =="
            # create a release and upload xcframework zip
            ZIP_NAME="${external_prefixless_tag}-${key}.xcframework.zip"
            rm -f "/tmp/${ZIP_NAME}"
            (cd $(dirname "$XC_OUTPUT") && zip -r "/tmp/${ZIP_NAME}" "$(basename "$XC_OUTPUT")")

            # Ensure release exists (create if missing). tolerate 'already exists' / concurrency.
            if gh release view "${external_prefixless_tag}" --repo "${external_repo}" >/dev/null 2>&1; then
              echo "‚úÖ Release '${external_prefixless_tag}' already exists on ${external_repo}."
            else
              echo "‚û°Ô∏è Creating release ${external_prefixless_tag} on ${external_repo}..."
              if ! gh api -X POST "repos/${external_repo}/releases" \
                -f tag_name="$external_prefixless_tag" \
                -f name="$external_prefixless_tag" \
                -f body="$body" \
                -F prerelease=$prerelease >/dev/null 2>&1; then
                echo "‚ö†Ô∏è Warning: release creation returned non-zero (may already exist or transient error). Continuing to upload attempt."
              else
                echo "‚úÖ Release created: ${external_prefixless_tag}"
              fi
            fi

            # Upload artifact (always attempt). Use --clobber to replace existing asset with same name.
            if gh release upload "${external_prefixless_tag}" "/tmp/${ZIP_NAME}" --repo "${external_repo}" --clobber; then
              echo "‚úÖ Uploaded ${ZIP_NAME} to ${external_repo} release ${external_prefixless_tag}."
            else
              echo "‚ö†Ô∏è WARN: failed to upload ${ZIP_NAME} to ${external_repo} release ${external_prefixless_tag}."
            fi

            echo "External release created for $external_repo"

            #
            # --- Publish to Pod Repo (clone, update podspec, push tag & release with podspec + xcframework) ---
            #
            if [ "$key" = "cam" ]; then
              POD_REPO="Truvideo/truvideo-sdk-ios-camera-pod"
              PODSPEC_NAME="truvideo-sdk-camera.podspec"
            else
              POD_REPO="Truvideo/truvideo-sdk-ios-core-pod"
              PODSPEC_NAME="truvideo-sdk-core.podspec"
            fi

            echo "== Preparing Pod repo $POD_REPO =="
            rm -rf /tmp/podrepo || true
            git clone "https://${{ secrets.GH_EXTERNAL_PAT }}@github.com/${POD_REPO}.git" /tmp/podrepo
            cd /tmp/podrepo
            git config user.name "truvideo[bot]"
            git config user.email "truvideo[bot]@users.noreply.github.com"

            # copy xcframework and podspec
            rm -rf TruvideoSdk*.xcframework || true
            cp -R "$GITHUB_WORKSPACE/${XC_OUTPUT}" .
            if [ -f "../${PODSPEC_NAME}" ]; then
              cp "$GITHUB_WORKSPACE/${PODSPEC_NAME}" . || true
            fi

            # update podspec version line (simple sed)
            sed -i '' "s/spec.version *= *'.*'/spec.version = '$external_prefixless_tag'/" "$PODSPEC_NAME" || true

            # create branch named as version and commit
            git checkout -b "$external_prefixless_tag" || git checkout "$external_prefixless_tag" || true
            git add .
            if ! git diff --cached --quiet; then
              git commit -m "Release $external_prefixless_tag"
            fi

            # create and push tag (lightweight) on pod repo
            git tag "$external_prefixless_tag" || true
            git push "https://${{ secrets.GH_EXTERNAL_PAT }}@github.com/${POD_REPO}.git" "refs/heads/${external_prefixless_tag}:refs/heads/${external_prefixless_tag}" || true
            git push "https://${{ secrets.GH_EXTERNAL_PAT }}@github.com/${POD_REPO}.git" "refs/tags/${external_prefixless_tag}" || {
              echo "ERROR pushing tag to pod repo ${POD_REPO}"
              exit 1
            }
            # Ensure pod repo release exists (create if missing)
            if gh release view "${external_prefixless_tag}" --repo "${POD_REPO}" >/dev/null 2>&1; then
              echo "‚úÖ Pod release ${external_prefixless_tag} already exists on ${POD_REPO}."
            else
              echo "‚û°Ô∏è Creating pod release ${external_prefixless_tag} on ${POD_REPO}..."
              if ! gh api -X POST "repos/${POD_REPO}/releases" \
                -f tag_name="$external_prefixless_tag" \
                -f name="$external_prefixless_tag" \
                -f body="$body" \
                -F prerelease=$prerelease >/dev/null 2>&1; then
                echo "‚ö†Ô∏è Warning: pod release creation returned non-zero (may already exist or transient error). Continuing to upload attempt."
              else
                echo "‚úÖ Pod release created: ${external_prefixless_tag}"
              fi
            fi

            # Upload xcframework zip (always attempt; --clobber to replace existing asset)
            if gh release upload "${external_prefixless_tag}" "${XC_OUTPUT}.zip" --repo "${POD_REPO}" --clobber; then
              echo "‚úÖ Uploaded ${XC_OUTPUT}.zip to ${POD_REPO} release ${external_prefixless_tag}."
            else
              echo "‚ö†Ô∏è WARN: failed to upload ${XC_OUTPUT}.zip to ${POD_REPO} release ${external_prefixless_tag}."
            fi

            # Upload podspec (always attempt)
            if gh release upload "${external_prefixless_tag}" "$PODSPEC_NAME" --repo "${POD_REPO}" --clobber; then
              echo "‚úÖ Uploaded ${PODSPEC_NAME} to ${POD_REPO} release ${external_prefixless_tag}."
            else
              echo "‚ö†Ô∏è WARN: failed to upload ${PODSPEC_NAME} to ${POD_REPO} release ${external_prefixless_tag}."
            fi
            echo "Pod repo release created / updated for ${POD_REPO}"

            #
            # Try pod trunk push (if using public cocoapods trunk). This requires COCOAPODS_TRUNK_TOKEN be configured.
            #
            if [ -n "${COCOAPODS_TRUNK_TOKEN:-}" ]; then
              echo "Attempting pod trunk push for $PODSPEC_NAME (version $external_prefixless_tag)"
              MAX_RETRIES=3
              RETRY_DELAY=30
              ATTEMPT=1
              while [ $ATTEMPT -le $MAX_RETRIES ]; do
                echo "pod trunk push attempt $ATTEMPT"
                pod trunk push "$PODSPEC_NAME" --allow-warnings && break
                echo "pod trunk push failed; sleeping $RETRY_DELAY"
                sleep $RETRY_DELAY
                ATTEMPT=$((ATTEMPT+1))
              done
              if [ $ATTEMPT -gt $MAX_RETRIES ]; then
                echo "WARNING: pod trunk push did not succeed after $MAX_RETRIES attempts"
              fi
            else
              echo "COCOAPODS_TRUNK_TOKEN not set; skipping pod trunk push (only updated pod repo)."
            fi

            #
            # --- Update SPM repo (Package.swift) ---
            #
            if [ "$key" = "cam" ]; then
              SPM_REPO="Truvideo/truvideo-sdk-ios-camera"
              PACKAGE_FILE="Package.swift"
              BINARY_NAME="TruvideoSdkCamera"
            else
              SPM_REPO="Truvideo/truvideo-sdk-ios-core"
              PACKAGE_FILE="Package.swift"
              BINARY_NAME="TruvideoSdkCore"
            fi

            echo "== Updating SPM repo ${SPM_REPO} =="
            rm -rf /tmp/spm || true
            git clone "https://${{ secrets.GH_EXTERNAL_PAT }}@github.com/${SPM_REPO}.git" /tmp/spm
            cd /tmp/spm
            git config user.name "truvideo[bot]"
            git config user.email "truvideo[bot]@users.noreply.github.com"

            # prepare zip for download URL in Package.swift
            RELEASE_ZIP_NAME="${external_prefixless_tag}-${key}.xcframework.zip"
            # ensure release zip exists in external repo (it should have been uploaded above)
            # compute checksum (use swift tool if available)
            if command -v swift >/dev/null 2>&1; then
              curl -L -o "/tmp/${RELEASE_ZIP_NAME}" "https://github.com/${external_repo}/releases/download/${external_prefixless_tag}/${ZIP_NAME}"
                if [ $? -ne 0 ] || [ ! -s "/tmp/${RELEASE_ZIP_NAME}" ]; then
                  echo "Error: Failed to download /tmp/${RELEASE_ZIP_NAME} from GitHub releases." >&2
                  exit 1
                fi
              CHECKSUM=$(swift package compute-checksum "/tmp/${RELEASE_ZIP_NAME}" 2>/dev/null)
            else
              # fallback: sha256
              curl -L -o "/tmp/${RELEASE_ZIP_NAME}" "https://github.com/${external_repo}/releases/download/${external_prefixless_tag}/${ZIP_NAME}"
                if [ $? -ne 0 ] || [ ! -s "/tmp/${RELEASE_ZIP_NAME}" ]; then
                  echo "Error: Failed to download /tmp/${RELEASE_ZIP_NAME} from GitHub releases." >&2
                  exit 1
                fi
              CHECKSUM=$(shasum -a 256 "/tmp/${RELEASE_ZIP_NAME}" | awk '{print $1}')
            fi

            PACKAGE_CONTENT="// swift-tools-version:5.8

            import PackageDescription
                        
            let package = Package(
              name: \"${BINARY_NAME}\",
              products: [
                .library(name: \"${BINARY_NAME}\", targets: [\"${BINARY_NAME}Targets\"])
              ],
              targets: [
                .binaryTarget(
                  name: \"${BINARY_NAME}\",
                  url: \"https://github.com/${external_repo}/releases/download/${external_prefixless_tag}/${ZIP_NAME}\",
                  checksum: \"${CHECKSUM}\"
                ),
                .target(name: \"${BINARY_NAME}Targets\", dependencies: [\"${BINARY_NAME}\"], path: \"Sources\")
              ]
            )
            "
            echo "$PACKAGE_CONTENT" > "$PACKAGE_FILE"
            if git show-ref --verify --quiet "refs/heads/$external_prefixless_tag"; then
              git checkout "$external_prefixless_tag"
            else
              git checkout -b "$external_prefixless_tag"
            fi
            git add "$PACKAGE_FILE"
            if ! git diff --cached --quiet; then
              git commit -m "SPM: Update Package.swift for $external_prefixless_tag"
            fi
            git push "https://${{ secrets.GH_EXTERNAL_PAT }}@github.com/${SPM_REPO}.git" "refs/heads/${external_prefixless_tag}" || true
            git tag "$external_prefixless_tag" || true
            git push "https://${{ secrets.GH_EXTERNAL_PAT }}@github.com/${SPM_REPO}.git" "refs/tags/${external_prefixless_tag}" || true
            gh api -X POST "repos/${SPM_REPO}/releases" -f tag_name="$external_prefixless_tag" -f name="$external_prefixless_tag" -f body="$body" -F prerelease=$prerelease >/dev/null || true
            echo "SPM repo updated: ${SPM_REPO}"
          }

          for s in ${{ steps.scope.outputs.aff }}; do
            for cut_type in $(echo "${{ steps.scope.outputs.cut }}" | tr ',' ' '); do
              cut_for "$s" "$cut_type"
            done
          done

          echo "---- ‚û°Ô∏è‚û°Ô∏è‚û°Ô∏è‚û°Ô∏è‚û°Ô∏è DEBUG VERSION CALC ----"
          echo "prefix=$prefix" 
          echo "cut_type=$cut_type"
          echo

          echo "Tags founded for prefix:"

          git tag -l "${prefix}-*" | sort -V
          echo

          echo "Last prod detected:"
          git tag -l "${prefix}-*" --sort=-v:refname \
          | grep -E "^${prefix}-[0-9]+\.[0-9]+\.[0-9]+$" \
          | head -n1
          echo

          echo "Last prod SHA:"

          [ -n "$last_prod" ] && git rev-list -n1 "$last_prod"
          echo

          echo "Range using for bump: $range"
          echo "Commits founded:"
          git log --oneline $range
          echo "-----------------------------"
